"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const deepmerge_1 = tslib_1.__importDefault(require("deepmerge"));
const TYPE = '%TYPE';
const VERSION = '%VERSION';
const defaultOptions = {
    label: 'released',
    prereleaseLabel: 'prerelease',
    lockIssues: false,
    message: `:rocket: ${TYPE} was released in \`${VERSION}\` :rocket:`
};
const closeIssue = /(?:Close|Closes|Closed|Fix|Fixes|Fixed|Resolve|Resolves|Resolved)\s((?:#\d+(?:,\s)?)+)/gi;
/** Determine if string is a canary version */
const isCanary = (version) => version.match('canary');
/** Comment on merged pull requests and issues with the new version */
class ReleasedLabelPlugin {
    /** Initialize the plugin with it's options */
    constructor(options = {}) {
        /** The name of the plugin */
        this.name = 'Released Label';
        this.options = deepmerge_1.default(defaultOptions, options);
    }
    /** Tap into auto plugin points. */
    apply(auto) {
        auto.hooks.modifyConfig.tap(this.name, config => {
            if (!config.labels.find(l => l.name === this.options.label)) {
                config.labels.push({
                    name: this.options.label,
                    description: 'This issue/pull request has been released.',
                    releaseType: 'none'
                });
            }
            if (!config.labels.find(l => l.name === this.options.prereleaseLabel)) {
                config.labels.push({
                    name: this.options.prereleaseLabel,
                    description: 'This change is available in a prerelease.',
                    releaseType: 'none'
                });
            }
            return config;
        });
        auto.hooks.afterRelease.tapPromise(this.name, async ({ newVersion, commits, response }) => {
            var _a, _b;
            if (!newVersion) {
                return;
            }
            const head = commits[0];
            if (!head) {
                return;
            }
            const skipReleaseLabels = (((_a = auto.config) === null || _a === void 0 ? void 0 : _a.labels.filter(l => l.releaseType === 'skip')) || []).map(l => l.name);
            const isSkipped = head.labels.find(label => skipReleaseLabels.includes(label));
            if (isSkipped) {
                return;
            }
            const isPrerelease = Array.isArray(response)
                ? response.some(r => { var _a; return (_a = r) === null || _a === void 0 ? void 0 : _a.data.prerelease; })
                : (_b = response) === null || _b === void 0 ? void 0 : _b.data.prerelease;
            await Promise.all(commits.map(async (commit) => this.addReleased(auto, commit, newVersion, isPrerelease)));
        });
    }
    /** Add the release label + other stuff to a commit */
    async addReleased(auto, commit, newVersion, isPrerelease = false) {
        var _a, _b, _c;
        const messages = [commit.subject];
        if (commit.pullRequest) {
            const branch = (_b = (await ((_a = auto.git) === null || _a === void 0 ? void 0 : _a.getPullRequest(commit.pullRequest.number)))) === null || _b === void 0 ? void 0 : _b.data.head.ref;
            if (branch && ((_c = auto.config) === null || _c === void 0 ? void 0 : _c.prereleaseBranches.includes(branch))) {
                return;
            }
            await this.addCommentAndLabel({
                auto,
                newVersion,
                prOrIssue: commit.pullRequest.number,
                isPrerelease
            });
            const pr = await auto.git.getPullRequest(commit.pullRequest.number);
            pr.data.body.split('\n').map(line => messages.push(line));
            const commitsInPr = await auto.git.getCommitsForPR(commit.pullRequest.number);
            commitsInPr.map(c => messages.push(c.commit.message));
        }
        const issues = messages
            .map(message => message.match(closeIssue))
            .filter((r) => Boolean(r))
            .reduce((all, arr) => [...all, ...arr], [])
            .map(issue => issue.match(/#(\d+)/i))
            .filter((r) => Boolean(r))
            .map(match => Number(match[1]));
        await Promise.all(issues.map(async (issue) => {
            await this.addCommentAndLabel({
                auto,
                newVersion,
                prOrIssue: issue,
                isIssue: true,
                isPrerelease
            });
            if (this.options.lockIssues && !isCanary(newVersion) && !isPrerelease) {
                await auto.git.lockIssue(issue);
            }
        }));
    }
    /** Add the templated comment to the pr and attach the "released" label */
    async addCommentAndLabel({ auto, newVersion, prOrIssue, isIssue = false, isPrerelease = false }) {
        // leave a comment with the new version
        const message = this.createReleasedComment(isIssue, newVersion);
        await auto.comment({ message, pr: prOrIssue, context: 'released' });
        // Do not add released to issue/label for canary versions
        if (isCanary(newVersion)) {
            return;
        }
        // add a `released` label to a PR
        const labels = await auto.git.getLabels(prOrIssue);
        if (isPrerelease) {
            if (!labels.includes(this.options.prereleaseLabel)) {
                await auto.git.addLabelToPr(prOrIssue, this.options.prereleaseLabel);
            }
        }
        else if (!labels.includes(this.options.label)) {
            await auto.git.addLabelToPr(prOrIssue, this.options.label);
            if (labels.includes(this.options.prereleaseLabel)) {
                await auto.git.removeLabel(prOrIssue, this.options.prereleaseLabel);
            }
        }
    }
    /** Create a comment that fits the context (pr of issue) */
    createReleasedComment(isIssue, version) {
        return this.options.message
            .replace(new RegExp(TYPE, 'g'), isIssue ? 'Issue' : 'PR')
            .replace(new RegExp(VERSION, 'g'), version);
    }
}
exports.default = ReleasedLabelPlugin;
//# sourceMappingURL=index.js.map